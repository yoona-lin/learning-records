# learning-records

## Firebug 与 Firefox

> 看了一些关于firebug编辑器的操作，安装时才知道已经没更新了，取消了整个编辑器了，把它内置在Firefox浏览器的“开发者工具”一项中了，试着用了一下，是个很不错的前端编辑环境，感觉很不错，一些请求跟响应很清晰，对源码的编辑与修改也很方便，推荐

```shall
2019.10.29
```

## webpack + vue 项目搭建流程

> 慕课网址：https://www.imooc.com/learn/935

> 课程讲了如何配置开发前端项目工程；实现一个简单的TODO应用：优化配置达到上线标准；

> 关于webpack项目的搭建流程，基本的流程，清晰易懂，多看，跟着搭建一遍

> 一个不错的分享：https://github.com/carrieguo/vue.js-todolist

> 整理出两个文件夹，分别是项目的静态搭建和完成打包配置，成功运行

```shall
2019.11.03
```

## 浏览器开发者工具使用技巧
> https://www.imooc.com/learn/759

> 很实用与详细的一个教程，很多没这么知道但好用的技巧，值得多看多用，特别是对js编程的调试

```shall
2019.11.05
```

## vuex 了解了解

> https://vuex.vuejs.org/zh/

> Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。

> 把组件的共享状态抽取出来，以一个全局单例模式管理呢,在这种模式下，我们的组件树构成了一个巨大的“视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为！这是vuex的基本思想。

> 如果您的应用够简单，您最好不要使用 Vuex。一个简单的 store 模式就足够您所需了。但是，如果您需要构建一个中大型单页应用，您很可能会考虑如何更好地在组件外部管理状态，Vuex 将会成为自然而然的选择。

```shall
2019.11.12
```

## ECMAScript 6 入门

let 与 const 命令
> let 声明变量的有效域情况，let声明的变量只在它所在的代码块有效，不存在变量提升

> const 声明只读常量，声明后立即初始化，不能更改

> 块级作用域 {} 的使用


变量的结构赋值
> 数组的对应赋值，一一对应

> 对象的结构赋值，变量必须与属性同名，才能取到正确的赋值

> 字符串也可以解构赋值,字符串被转换成了一个类似数组的对象

箭头函数
> var f = v => v;   // 等同于  var f = function (v) {  return v;  };

> var f = () => 5;  // 等同于  var f = function () { return 5 };

Symbol

> ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。

> Symbol 值通过Symbol函数生成。let s = Symbol(); 这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。

Set 和 Map 数据结构
> ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。Set本身是一个构造函数，用来生成 Set 数据结构。const s = new Set();

> ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。

Proxy
> Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程,
Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。

> ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。
var proxy = new Proxy(target, handler);

Promise 对象

> 所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果，等主线程运行结束再返回结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。

> Promise对象有以下两个特点。
（1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。
（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。


```shall
2019.11.13 - 2019.11.
```
